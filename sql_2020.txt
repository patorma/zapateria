system cls;
 SOURCE Downloads/zapateria/factura.sql;

show create table <table>;
Para ver más información sobre la estructura de la tabla.

FOREIGN KEY (columna) REFERENCES tabla_referencia (llave_primaria);


 Downloads/zapateria/sentencias.sql;

CHARSET utf8 COLLATE utf8_spanish_ci 


VALORES ÚNICOS
Como sabemos, si nosotros necesitamos validar valores únicos usaremos el constraint UNIQUE.

CREATE TABLE usuarios( 
  usuario_id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  nombre VARCHAR(50) UNIQUE
);
Otra forma de expresarlo, es de la siguiente manera.

CREATE TABLE usuarios( 
  usuario_id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  nombre VARCHAR(50),
  CONSTRAINT UNIQUE (nombre)
);
La palabra CONSTRAINT es opcional, sin embargo, por temas de legibilidad recomiendo colocarla.

VALORES MÚTIPLES COLUMNAS
Si necesitamos validar el valor único de una combinación de columnas lo haremos de la siguiente manera.

En este caso queremos validar que la combinación de nombre, apellido y matricula sean unicas en la tabla.

CREATE TABLE usuarios( 
  usuario_id INT UNSIGNED NOT NULL AUTO_INCREMENT,
  nombre VARCHAR(50),
  apellido VARCHAR(50),
  matricula VARCHAR(10),
  CONSTRAINT unique_combinacion UNIQUE (nombre, apellido, matricula),
  PRIMARY KEY (usuario_id)
);
LLAVES PRIMARIAS
Existen un par de formas con las cuales nosotros podemos definir un campo como una llave primaria.

CREATE TABLE usuarios( 
  usuario_id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT
);
o

CREATE TABLE usuarios( 
  usuario_id INT UNSIGNED AUTO_INCREMENT,
  PRIMARY KEY(usuario_id)
);
En ambos casos el resultado es el mismo.

--------------------------------------------------------------------
Nosotros podemos modificar la definición de una tabla una vez esta se haya creado, para ello, nos apoyaremos de la sentencia ALTER TABLE.

Aquí un listado de algunas modificaciones que podemos realizar (Las más comunes).

Renombrar tabla.

Renombrar la tabla usuarios por users.

ALTER TABLE usuarios RENAME users;
Agregar una nueva columna.

Agregar a la tabla usuarios, la columna email de tipo VARCHAR con máximo de 50 caracteres.

ALTER TABLE usuarios ADD email VARCHAR(50);
Agregar una nueva columna con constraints.

Agregar a la tabla usuarios, la columna email, validando su presencia.

ALTER TABLE usuarios ADD email VARCHAR(50) NOT NULL DEFAULT '';
Agregar a la tabla usuarios, la columna email, validando su valor único.

ALTER TABLE tabla ADD columna VARCHAR(50) UNIQUE;
Eliminar una columna

Eliminar la columna email de la tabla usuarios.

ALTER TABLE usuarios DROP COLUMN email;
Modificar el tipo de dato de una columna

Modificar el tipo de dato de la columna teléfono, (tabla usuarios) de INT a VARCHAR, máximo 50 caracteres.

ALTER TABLE usuarios MODIFY telefono VARCHAR(50);
Generar una llave primaria.

Generar una llave primaria a la tabla usuarios.

ALTER TABLE usuarios ADD id INT UNSIGNED NOT NULL AUTO_INCREMENT, ADD PRIMARY KEY (id);
Agregar llave foránea.

Agregar una llave foranea a la tabla usuarios, con referencia a la tabla grupos.

ALTER TABLE usuarios ADD FOREIGN KEY(grupo_id) REFERENCES grupos(grupo_id);
Eliminar llaves foráneas

Eliminar la llave foranea grupo_id de la tabla usuarios.

ALTER TABLE usuarios DROP FOREIGN KEY grupo_id;

Operadores lógicos 
--------------------------------------
 SELECT * FROM libros WHERE (autor_id = 1 AND titulo = 'Carrie') OR (autor_id = 5  AND titulo = 'El hobbit');

Condicionar consultas con valores nulos
-------------------------------------------
 SELECT * FROM  autores WHERE seudonimo IS NULL;

con operador de seguridad:

 SELECT * FROM  autores WHERE seudonimo <=> NULL;

Obtenemos los registros no nulos
-----------------------------------------------------
 SELECT * FROM  autores WHERE seudonimo IS NOT NULL; es recomendable el IS porque se puede agregar mas argumentos tipo NOT

Obtener registros mediante rangos
----------------------------------------
SELECT titulo, fecha_publicacion FROM libros 
WHERE fecha_publicacion BETWEEN '1995-01-01' AND'2015-01-31';


Búsquedas por listas
--------------------------------
SELECT * FROM libros WHERE titulo IN ('Ojos de fuego', 'Cujo','El hobbit','La torre oscura 7 La torre oscura');

Registros unicos
------------------------
SELECT DISTINCT titulo FROM libros;


alias
------------------------
SELECT 9 *10; AS resultado;

select autor_id AS autor,titulo AS nombre from libros AS books;     


UPDATE 
--------------------

UPDATE libros SET descripcion = 'Nuevo cambio', ventas = 50 WHERE titulo = 'El hobbit';


forma optima y correcta

UPDATE libros SET descripcion = 'Nuevo cambio', ventas = 50 WHERE libro_id = 41;

Eliminar registros
----------------------------------------------------------------
DELETE FROM libros WHERE autor_id = 55;


Eliminacion en cascada
--------------------------------------



Intente comentar una respuesta mas descriptiva, pero al parecer las imagenes no las adjunta. Te comento los pasos para modificar una FOREIGN KEY en una tabla con registros.

ALTER TABLE libros DROP CONSTRAINT libros_ibfk_1;

ALTER TABLE libros DROP KEY autor_id;

ALTER TABLE libros ADD FOREIGN KEY (autor_id) REFERENCES autores(autor_id) ON DELETE CASCADE;


 SOURCE Downloads/zapateria/sentencias.sql;


--Eliminar en cascada segunda forma de declararlo
-- ALTER TABLE ADD FOREIGN KEY (autor_id) REFERENCES autores(autor_id) ON DELETE CASCADE


eliminar registro de una tabla
--------------------------------
TRUNCATE TABLE libros;
TRUNCATE resetea la definicion de la tabla

Funciones
Funciones sobre strings
-----------------------------
SELECT CONCAT(nombre,apellido) FROM autores;
SELECT CONCAT(nombre," ", apellido) FROM autores;
 SELECT CONCAT(nombre," ", apellido) AS nombre_completo FROM autores;

SELECT LENGTH("Hola mundo");

autores con nombres de caracteres mayores a 7
SELECT * FROM autores WHERE LENGTH(nombre) > 7;

 UPPER Y LOWER
-----------------------
SELECT UPPER(nombre), LOWER(nombre)  FROM autores;

TRIM elimina espacios de un string
 SELECT TRIM("     cadena con espacio al inicio y al final   ");

SELECT
     LEFT("Esta es una cadena de caracteres",5) AS substring_izquierdo,
     RIGHT("Esta es una cadena de caracteres",10) AS substring_derecho;

LEFT devuelve, en este caso, los 5 primeros caracteres del string original de izquierda a derecha 
RIGHT devuelve,en este caso, los 10 primeros caracteres del string original de derecha a izquierda

obtener todos los titulos cuyo titulo comienze con la palabra harry potter
------------------------------------------------------------------------------
SELECT * FROM libros WHERE LEFT(titulo, 12) = 'Harry Potter'

obtener todos los titulos cuyo titulo termine con anillo
------------------------------------------------------------------------------

SELECT * FROM libros WHERE RIGHT(titulo, 6) = 'anillo';

Funcion RAND()
----------------------------------------------------------
SELECT RAND(); NUMEROS ALETORIOS ENTRE 0  Y 1

SELECT ROUND() NUMEROS ALEATORIOS ENTRE  0 Y 100
SELECT ROUND( RAND() * 100);

TRUNCATE REDONDEA DECIMALES PRIMER PARAMETRO NUMERO FLOTANTE Y DECIMALES A OBTENER
 SELECT TRUNCATE(1.123456789,3);

CALCULA LA POTENCIA DE UN NUMERO primer parametro la base y el otro la potencia
SELECT POW(2,16);
o

SELECT POWER();

obtiene fecha actual
1 SELECT now();
2 SET @now = NOW();
3 SELECT SECOND(@now),MINUTE(@now),HOUR(@now),MONTH(@now),YEAR(@now);

si quiero convertirlo a date 
4 select date(@now);
 informacion de un dia en concreto
libros creados el dia de hoy
SELECT * FROM libros WHERE DATE(fecha_creacion) = CURDATE();

select curdate();  fecha de hoy

Funcion para sumarle dias a una fecha

SELECT @now + INTERVAL 30 DAY;

Fecha operador(+/-) INTERVAL valor TIPO(SECOND, MINUTE,HOUR, DAY,WEEK, MONTH, YEAR);

Funciones sobre condiciones
 SELECT IF( 10 > 9, "El número si es mayor", "El número no es mayor");

SELECT IF(paginas = 0, "El libro no posee páginas",paginas) FROM libros; 


UPDATE libros SET paginas = 10 WHERE libro_id > 20;
SELECT IF(paginas = 0, "El libro no posee páginas",paginas) FROM libros;   

// Evaluar si una condicion es null
SELECT IFNULL(seudonimo, "El autor no cuenta con un seudonimo") FROM autores;

crear funciones
------------------------

crear funcion que nos permita agregar dias a una fecha 

DELIMITER //
CREATE FUNCTION agregar_dias(fecha DATE,dias INT)
-- Se indica que tipo de dato retorna la funcion
RETURNS DATE
BEGIN
    RETURN fecha + INTERVAL dias DAY;
END//
DELIMITER ;

listar funciones
SHOW FUNCTION STATUS WHERE db = database() AND type = "FUNCTION"\G;



DELIMITER //

CREATE FUNCTION obtener_paginas()
RETURNS INT
BEGIN
  SET @paginas = (SELECT (ROUND( RAND() * 100 ) * 4 ));
  RETURN @paginas;
END//


eliminar funcion
DROP FUNCTION agregar_dias;
ctrl

Ejecutar sentencias dentro de funciones
funcion para establecer la cantidad de paginas de un libro


DELIMITER //

CREATE FUNCTION obtener_paginas()
RETURNS INT
BEGIN
  SET @paginas = (SELECT (ROUND( RAND() * 100 ) * 4 ));
  RETURN @paginas;
END//

DELIMITER ;

UPDATE libros SET paginas = obtener_paginas();

select * from libros\G;  con la \G mostramos la consultas por cards
sentencias avanzadas
------------------------------------
Búsqueda mediante strings
------------------------------------
Si quiero un string que empieze al principio del texto orginal

SELECT * FROM libros WHERE titulo LIKE 'Harry potter%';

String que muestre los titulos de los libros que terminen con anillo
 SELECT * FROM libros WHERE titulo LIKE '%anillo'\G;

String que muestre los titulos de los libros que contenga la palabra la
SELECT * FROM libros WHERE titulo LIKE '%la%'\G;


Obtener todos los libros cuyo titulo posea 5 caracteres y que en el tercer caracter cuente con la letra b
dos rayas abajo una b y dos rayas abajo

SELECT * FROM libros WHERE titulo LIKE '__b__'; 


Obtener todos los libros cuyo titulo tenga en su segundo caracter la letra a

SELECT * FROM libros WHERE titulo LIKE '_a%';



Obtener todos los libros cuyo titulo tenga en su segundo caracter la letra a y en su quinto caracter la letra o


SELECT * FROM libros WHERE titulo LIKE '_a__o%';


Obtener todos los libros cuyo titulo comienze con la letra h o con la letra l
forma no optima

SELECT autor_id,titulo FROM libros WHERE titulo LIKE 'H%' OR titulo LIKE 'L%';
SELECT autor_id,titulo FROM libros WHERE LEFT(titulo,1) = 'H' OR LEFT(titulo,1) = 'L';

con expresiones regulares

 SELECT titulo FROM libros WHERE titulo REGEXP '^[HL]';

Y asi sucesivamente 
SELECT titulo FROM libros WHERE titulo REGEXP '^[HLAVTZ]';


Ordenamiento de registros
------------------------------
SELECT titulo FROM libros ORDER BY titulo;

Ordenar en forma descendente
-----------------------
SELECT titulo FROM libros ORDER BY titulo DESC;


Ordenar en forma ascendente
---------------------------------
 SELECT titulo FROM libros ORDER BY titulo ASC;

Ordenar en forma descendente números
------------------------------------
 SELECT libro_id, titulo FROM libros ORDER BY libro_id DESC;

Ordenar por condicion and
----------------------------------------------------------------------
 SELECT libro_id, titulo FROM libros ORDER BY libro_id AND titulo ASC;


 Limitar registros
-----------------------------------
SELECT titulo FROM libros LIMIT 10;  a 10

obtener el titulo de los primeros 5 libros escritos por el auttor de id 2
primero va la condicion y despues el limit
 SELECT titulo FROM libros WHERE autor_id = 2 LIMIT 5;


paginar resultados  
 SELECT libro_id, titulo FROM libros LIMIT 0,5;

SELECT libro_id, titulo FROM libros LIMIT 5,5;

SELECT libro_id, titulo FROM libros LIMIT 10,5;
 

ver ¿Qué son las funciones de agreación?

Contar la cantidad de autores de libros 
SELECT COUNT(*)  FROM autores;

SELECT COUNT(*) AS total  FROM autores;

CONTAR TODOS ,LOS AUTORES QUE TENGAN SEUDONIMOS
 SELECT COUNT(*) AS total  FROM autores WHERE seudonimo IS NOT NULL;

Se puede agregar columnas la misma consulta de arriba pero sin condicion
obtener la cantidad de autores que posean algun seudonimo
SELECT COUNT(seudonimo) AS total FROM autores;

Con las funciones de agregacion se trabajan las columnas siempre y cuando el registro posea algun valor si el registro no tiene valor o
es null no es tomado en cuenta

DELIMITER //
CREATE FUNCTION obtener_ventas() 
RETURNS INT
BEGIN
  SET @paginas = (SELECT (ROUND(RAND() * 100) * 6));
  RETURN @paginas;
END//;
DELIMITER ;

funcion de agregacion de sum
SELECT SUM(ventas) FROM libros;

Funciones de agregacion MIN MAX

El libro que tuvo mayor venta
SELECT MAX(ventas) FROM libros;

El libro que tuvo menor venta
SELECT MIN(ventas) FROM libros;


AVG Saca promedio de ventas
 SELECT AVG(ventas) FROM libros;

solo devuelven un solo valor

agrupamiento
------------------------------------------

agrupamos por autor (autor_id) cuantos libros se vendieron
SELECT autor_id, SUM(ventas) FROM libros GROUP BY autor_id;



SELECT autor_id, SUM(ventas) AS total FROM libros GROUP BY autor_id ORDER BY  total DESC LIMIT 1;

Despues de agrupar se agregan las funciones de agregacion

condiciones bajo agrupamiento
--------------------------------------
no se puede condicionar una funcion de agregacion con la clausula WHERE: 
ejemplo:

SELECT autor_id, SUM(ventas) AS total FROM libros WHERE SUM(ventas)> 100 GROUP BY autor_id;
lo anterior esta malo ya que las funciones de agregacion se ejecutan despues de un grupo de datos
la condicion where se ejecuta antes de las funciones de agregacion la forma correcta e con HAVING
la solucion a lo anterior seria con la siguiente query:

Obtener todos los autores que hayan vendido más de 100 ejemplares:
SELECT autor_id, SUM(ventas) AS total FROM libros  GROUP BY autor_id HAVING SUM(ventas) > 100;

HAVING  es una clausula de soporte a la clausula WHERE nos permitira realizar filtros sobre un grupo de datos
nos permite utilizar las funciones de agregacion (SUM,COUNT,MIN, MAX) 


Unir resultados
----------------------------------------------------------------------------------
 SELECT CONCAT(nombre," ",apellido) FROM autores
 UNION
  SELECT CONCAT(nombre," ",apellidos) FROM usuarios;


En la union debe tener las mismas columnas

solucion
 SELECT CONCAT(nombre," ",apellido) AS nombre_completo, ""  AS email FROM autores
 UNION
  SELECT CONCAT(nombre," ",apellidos) AS nombre_completo, email FROM usuarios;


 SELECT CONCAT(nombre," ",apellido) AS nombre_completo, "", pais_origen AS email FROM autores
 UNION
  SELECT CONCAT(nombre," ",apellidos) AS nombre_completo, email , "" FROM usuarios;
-----------------------------------------------------------------------------------------------

DELIMITER //
CREATE FUNCTION obtener_ventas() 
RETURNS INT
BEGIN
  SET @paginas = (SELECT (ROUND( RAND() * 100) * 6));
  RETURN @paginas;
END//

subconsultas
problematica :
Obtener el nombre completo de todos los autores cuyos valores hayan superado el promedio

Introduccion:
SET @promedio = (SELECT AVG(ventas) FROM libros);

SELECT 
autor_id 
FROM libros
 GROUP BY autor_id 
 HAVING SUM(ventas) >  @promedio;

ahora veamos como hacer esto con subconsultas;

SELECT <-- esta se ejecuta despues 
autor_id 
FROM libros
 GROUP BY autor_id 
 HAVING SUM(ventas) > (SELECT AVG(ventas) FROM libros);<--- esta se ejecuta primero

El orden en la que se ejecutan las subconsultas son del nivel mas bajo al mas alto

Finalmente la solucion a la problematica planteada para la pregunta para subconsulta es:

SELECT CONCAT(nombre, " ", apellido) AS nombre <-- esta se ejecuta al final(subconsulta principal)
FROM autores
WHERE autor_id IN(
SELECT <-- esta se ejecuta en segundo lugar
autor_id 
FROM libros
 GROUP BY autor_id 
 HAVING SUM(ventas) > (SELECT AVG(ventas) FROM libros)); <--- esta se ejecuta primero

la primera subconsulta devuelve el promedio
la segunda una lista de id 
y la principal el nombre completo en base a una lista 

Obtener el mensaje Disponible si el libro de titulo el hobbit se encuentra en nuestra tabla libros
en caso contrario ontener el mensaje No Disponible 

SELECT IF(
   EXISTS(SELECT libro_id FROM libros WHERE titulo = 'El hobbit'),
   'Disponible',
   'No Disponible'
 ) AS mensaje;


