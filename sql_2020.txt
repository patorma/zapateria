system cls;
 SOURCE Downloads/zapateria/factura.sql;

show create table <table>;
Para ver más información sobre la estructura de la tabla.

FOREIGN KEY (columna) REFERENCES tabla_referencia (llave_primaria);


 Downloads/zapateria/sentencias.sql;

CHARSET utf8 COLLATE utf8_spanish_ci 


VALORES ÚNICOS
Como sabemos, si nosotros necesitamos validar valores únicos usaremos el constraint UNIQUE.

CREATE TABLE usuarios( 
  usuario_id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  nombre VARCHAR(50) UNIQUE
);
Otra forma de expresarlo, es de la siguiente manera.

CREATE TABLE usuarios( 
  usuario_id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  nombre VARCHAR(50),
  CONSTRAINT UNIQUE (nombre)
);
La palabra CONSTRAINT es opcional, sin embargo, por temas de legibilidad recomiendo colocarla.

VALORES MÚTIPLES COLUMNAS
Si necesitamos validar el valor único de una combinación de columnas lo haremos de la siguiente manera.

En este caso queremos validar que la combinación de nombre, apellido y matricula sean unicas en la tabla.

CREATE TABLE usuarios( 
  usuario_id INT UNSIGNED NOT NULL AUTO_INCREMENT,
  nombre VARCHAR(50),
  apellido VARCHAR(50),
  matricula VARCHAR(10),
  CONSTRAINT unique_combinacion UNIQUE (nombre, apellido, matricula),
  PRIMARY KEY (usuario_id)
);
LLAVES PRIMARIAS
Existen un par de formas con las cuales nosotros podemos definir un campo como una llave primaria.

CREATE TABLE usuarios( 
  usuario_id INT UNSIGNED PRIMARY KEY AUTO_INCREMENT
);
o

CREATE TABLE usuarios( 
  usuario_id INT UNSIGNED AUTO_INCREMENT,
  PRIMARY KEY(usuario_id)
);
En ambos casos el resultado es el mismo.

--------------------------------------------------------------------
Nosotros podemos modificar la definición de una tabla una vez esta se haya creado, para ello, nos apoyaremos de la sentencia ALTER TABLE.

Aquí un listado de algunas modificaciones que podemos realizar (Las más comunes).

Renombrar tabla.

Renombrar la tabla usuarios por users.

ALTER TABLE usuarios RENAME users;
Agregar una nueva columna.

Agregar a la tabla usuarios, la columna email de tipo VARCHAR con máximo de 50 caracteres.

ALTER TABLE usuarios ADD email VARCHAR(50);
Agregar una nueva columna con constraints.

Agregar a la tabla usuarios, la columna email, validando su presencia.

ALTER TABLE usuarios ADD email VARCHAR(50) NOT NULL DEFAULT '';
Agregar a la tabla usuarios, la columna email, validando su valor único.

ALTER TABLE tabla ADD columna VARCHAR(50) UNIQUE;
Eliminar una columna

Eliminar la columna email de la tabla usuarios.

ALTER TABLE usuarios DROP COLUMN email;
Modificar el tipo de dato de una columna

Modificar el tipo de dato de la columna teléfono, (tabla usuarios) de INT a VARCHAR, máximo 50 caracteres.

ALTER TABLE usuarios MODIFY telefono VARCHAR(50);
Generar una llave primaria.

Generar una llave primaria a la tabla usuarios.

ALTER TABLE usuarios ADD id INT UNSIGNED NOT NULL AUTO_INCREMENT, ADD PRIMARY KEY (id);
Agregar llave foránea.

Agregar una llave foranea a la tabla usuarios, con referencia a la tabla grupos.

ALTER TABLE usuarios ADD FOREIGN KEY(grupo_id) REFERENCES grupos(grupo_id);
Eliminar llaves foráneas

Eliminar la llave foranea grupo_id de la tabla usuarios.

ALTER TABLE usuarios DROP FOREIGN KEY grupo_id;

Operadores lógicos 
--------------------------------------
 SELECT * FROM libros WHERE (autor_id = 1 AND titulo = 'Carrie') OR (autor_id = 5  AND titulo = 'El hobbit');

Condicionar consultas con valores nulos
-------------------------------------------
 SELECT * FROM  autores WHERE seudonimo IS NULL;

con operador de seguridad:

 SELECT * FROM  autores WHERE seudonimo <=> NULL;

Obtenemos los registros no nulos
-----------------------------------------------------
 SELECT * FROM  autores WHERE seudonimo IS NOT NULL; es recomendable el IS porque se puede agregar mas argumentos tipo NOT

Obtener registros mediante rangos
----------------------------------------
SELECT titulo, fecha_publicacion FROM libros 
WHERE fecha_publicacion BETWEEN '1995-01-01' AND'2015-01-31';


Búsquedas por listas
--------------------------------
SELECT * FROM libros WHERE titulo IN ('Ojos de fuego', 'Cujo','El hobbit','La torre oscura 7 La torre oscura');

Registros unicos
------------------------
SELECT DISTINCT titulo FROM libros;


alias
------------------------
SELECT 9 *10; AS resultado;

select autor_id AS autor,titulo AS nombre from libros AS books;     


UPDATE 
--------------------

UPDATE libros SET descripcion = 'Nuevo cambio', ventas = 50 WHERE titulo = 'El hobbit';


forma optima y correcta

UPDATE libros SET descripcion = 'Nuevo cambio', ventas = 50 WHERE libro_id = 41;

Eliminar registros
----------------------------------------------------------------
DELETE FROM libros WHERE autor_id = 55;


Eliminacion en cascada
--------------------------------------



Intente comentar una respuesta mas descriptiva, pero al parecer las imagenes no las adjunta. Te comento los pasos para modificar una FOREIGN KEY en una tabla con registros.

ALTER TABLE libros DROP CONSTRAINT libros_ibfk_1;

ALTER TABLE libros DROP KEY autor_id;

ALTER TABLE libros ADD FOREIGN KEY (autor_id) REFERENCES autores(autor_id) ON DELETE CASCADE;


 SOURCE Downloads/zapateria/sentencias.sql;


--Eliminar en cascada segunda forma de declararlo
-- ALTER TABLE ADD FOREIGN KEY (autor_id) REFERENCES autores(autor_id) ON DELETE CASCADE


eliminar registro de una tabla
--------------------------------
TRUNCATE TABLE libros;
TRUNCATE resetea la definicion de la tabla

Funciones
Funciones sobre strings
-----------------------------
SELECT CONCAT(nombre,apellido) FROM autores;
SELECT CONCAT(nombre," ", apellido) FROM autores;
 SELECT CONCAT(nombre," ", apellido) AS nombre_completo FROM autores;

SELECT LENGTH("Hola mundo");

autores con nombres de caracteres mayores a 7
SELECT * FROM autores WHERE LENGTH(nombre) > 7;

 UPPER Y LOWER
-----------------------
SELECT UPPER(nombre), LOWER(nombre)  FROM autores;

TRIM elimina espacios de un string
 SELECT TRIM("     cadena con espacio al inicio y al final   ");

SELECT
     LEFT("Esta es una cadena de caracteres",5) AS substring_izquierdo,
     RIGHT("Esta es una cadena de caracteres",10) AS substring_derecho;

LEFT devuelve, en este caso, los 5 primeros caracteres del string original de izquierda a derecha 
RIGHT devuelve,en este caso, los 10 primeros caracteres del string original de derecha a izquierda

obtener todos los titulos cuyo titulo comienze con la palabra harry potter
------------------------------------------------------------------------------
SELECT * FROM libros WHERE LEFT(titulo, 12) = 'Harry Potter'

obtener todos los titulos cuyo titulo termine con anillo
------------------------------------------------------------------------------

SELECT * FROM libros WHERE RIGHT(titulo, 6) = 'anillo';

Funcion RAND()
----------------------------------------------------------
SELECT RAND(); NUMEROS ALETORIOS ENTRE 0  Y 1

SELECT ROUND() NUMEROS ALEATORIOS ENTRE  0 Y 100
SELECT ROUND( RAND() * 100);

TRUNCATE REDONDEA DECIMALES PRIMER PARAMETRO NUMERO FLOTANTE Y DECIMALES A OBTENER
 SELECT TRUNCATE(1.123456789,3);

CALCULA LA POTENCIA DE UN NUMERO primer parametro la base y el otro la potencia
SELECT POW(2,16);
o

SELECT POWER();

obtiene fecha actual
1 SELECT now();
2 SET @now = NOW();
3 SELECT SECOND(@now),MINUTE(@now),HOUR(@now),MONTH(@now),YEAR(@now);

si quiero convertirlo a date 
4 select date(@now);
 informacion de un dia en concreto
libros creados el dia de hoy
SELECT * FROM libros WHERE DATE(fecha_creacion) = CURDATE();

select curdate();  fecha de hoy

Funcion para sumarle dias a una fecha

SELECT @now + INTERVAL 30 DAY;

Fecha operador(+/-) INTERVAL valor TIPO(SECOND, MINUTE,HOUR, DAY,WEEK, MONTH, YEAR);

Funciones sobre condiciones
 SELECT IF( 10 > 9, "El número si es mayor", "El número no es mayor");

SELECT IF(paginas = 0, "El libro no posee páginas",paginas) FROM libros; 


UPDATE libros SET paginas = 10 WHERE libro_id > 20;
SELECT IF(paginas = 0, "El libro no posee páginas",paginas) FROM libros;   

// Evaluar si una condicion es null
SELECT IFNULL(seudonimo, "El autor no cuenta con un seudonimo") FROM autores;

crear funciones
------------------------

crear funcion que nos permita agregar dias a una fecha 

DELIMITER //
CREATE FUNCTION agregar_dias(fecha DATE,dias INT)
-- Se indica que tipo de dato retorna la funcion
RETURNS DATE
BEGIN
    RETURN fecha + INTERVAL dias DAY;
END//
DELIMITER ;

listar funciones
SHOW FUNCTION STATUS WHERE db = database() AND type = "FUNCTION"\G;



DELIMITER //

CREATE FUNCTION obtener_paginas()
RETURNS INT
BEGIN
  SET @paginas = (SELECT (ROUND( RAND() * 100 ) * 4 ));
  RETURN @paginas;
END//


eliminar funcion
DROP FUNCTION agregar_dias;
ctrl

Ejecutar sentencias dentro de funciones
funcion para establecer la cantidad de paginas de un libro


DELIMITER //

CREATE FUNCTION obtener_paginas()
RETURNS INT
BEGIN
  SET @paginas = (SELECT (ROUND( RAND() * 100 ) * 4 ));
  RETURN @paginas;
END//

DELIMITER ;

UPDATE libros SET paginas = obtener_paginas();

select * from libros\G;  con la \G mostramos la consultas por cards
sentencias avanzadas
------------------------------------
Búsqueda mediante strings
------------------------------------
Si quiero un string que empieze al principio del texto orginal

SELECT * FROM libros WHERE titulo LIKE 'Harry potter%';

String que muestre los titulos de los libros que terminen con anillo
 SELECT * FROM libros WHERE titulo LIKE '%anillo'\G;

String que muestre los titulos de los libros que contenga la palabra la
SELECT * FROM libros WHERE titulo LIKE '%la%'\G;


Obtener todos los libros cuyo titulo posea 5 caracteres y que en el tercer caracter cuente con la letra b
dos rayas abajo una b y dos rayas abajo

SELECT * FROM libros WHERE titulo LIKE '__b__'; 


Obtener todos los libros cuyo titulo tenga en su segundo caracter la letra a

SELECT * FROM libros WHERE titulo LIKE '_a%';



Obtener todos los libros cuyo titulo tenga en su segundo caracter la letra a y en su quinto caracter la letra o


SELECT * FROM libros WHERE titulo LIKE '_a__o%';


Obtener todos los libros cuyo titulo comienze con la letra h o con la letra l
forma no optima

SELECT autor_id,titulo FROM libros WHERE titulo LIKE 'H%' OR titulo LIKE 'L%';
SELECT autor_id,titulo FROM libros WHERE LEFT(titulo,1) = 'H' OR LEFT(titulo,1) = 'L';

con expresiones regulares

 SELECT titulo FROM libros WHERE titulo REGEXP '^[HL]';

Y asi sucesivamente 
SELECT titulo FROM libros WHERE titulo REGEXP '^[HLAVTZ]';


Ordenamiento de registros
------------------------------
SELECT titulo FROM libros ORDER BY titulo;

Ordenar en forma descendente
-----------------------
SELECT titulo FROM libros ORDER BY titulo DESC;


Ordenar en forma ascendente
---------------------------------
 SELECT titulo FROM libros ORDER BY titulo ASC;

Ordenar en forma descendente números
------------------------------------
 SELECT libro_id, titulo FROM libros ORDER BY libro_id DESC;

Ordenar por condicion and
----------------------------------------------------------------------
 SELECT libro_id, titulo FROM libros ORDER BY libro_id AND titulo ASC;


 Limitar registros
-----------------------------------
SELECT titulo FROM libros LIMIT 10;  a 10

obtener el titulo de los primeros 5 libros escritos por el auttor de id 2
primero va la condicion y despues el limit
 SELECT titulo FROM libros WHERE autor_id = 2 LIMIT 5;


paginar resultados  
 SELECT libro_id, titulo FROM libros LIMIT 0,5;

SELECT libro_id, titulo FROM libros LIMIT 5,5;

SELECT libro_id, titulo FROM libros LIMIT 10,5;
 

ver ¿Qué son las funciones de agreación?

Contar la cantidad de autores de libros 
SELECT COUNT(*)  FROM autores;

SELECT COUNT(*) AS total  FROM autores;

CONTAR TODOS ,LOS AUTORES QUE TENGAN SEUDONIMOS
 SELECT COUNT(*) AS total  FROM autores WHERE seudonimo IS NOT NULL;

Se puede agregar columnas la misma consulta de arriba pero sin condicion
obtener la cantidad de autores que posean algun seudonimo
SELECT COUNT(seudonimo) AS total FROM autores;

Con las funciones de agregacion se trabajan las columnas siempre y cuando el registro posea algun valor si el registro no tiene valor o
es null no es tomado en cuenta

DELIMITER //
CREATE FUNCTION obtener_ventas() 
RETURNS INT
BEGIN
  SET @paginas = (SELECT (ROUND(RAND() * 100) * 6));
  RETURN @paginas;
END//;
DELIMITER ;

funcion de agregacion de sum
SELECT SUM(ventas) FROM libros;

Funciones de agregacion MIN MAX

El libro que tuvo mayor venta
SELECT MAX(ventas) FROM libros;

El libro que tuvo menor venta
SELECT MIN(ventas) FROM libros;


AVG Saca promedio de ventas
 SELECT AVG(ventas) FROM libros;

solo devuelven un solo valor

agrupamiento
------------------------------------------

agrupamos por autor (autor_id) cuantos libros se vendieron
SELECT autor_id, SUM(ventas) FROM libros GROUP BY autor_id;



SELECT autor_id, SUM(ventas) AS total FROM libros GROUP BY autor_id ORDER BY  total DESC LIMIT 1;

Despues de agrupar se agregan las funciones de agregacion

condiciones bajo agrupamiento
--------------------------------------
no se puede condicionar una funcion de agregacion con la clausula WHERE: 
ejemplo:

SELECT autor_id, SUM(ventas) AS total FROM libros WHERE SUM(ventas)> 100 GROUP BY autor_id;
lo anterior esta malo ya que las funciones de agregacion se ejecutan despues de un grupo de datos
la condicion where se ejecuta antes de las funciones de agregacion la forma correcta e con HAVING
la solucion a lo anterior seria con la siguiente query:

Obtener todos los autores que hayan vendido más de 100 ejemplares:
SELECT autor_id, SUM(ventas) AS total FROM libros  GROUP BY autor_id HAVING SUM(ventas) > 100;

HAVING  es una clausula de soporte a la clausula WHERE nos permitira realizar filtros sobre un grupo de datos
nos permite utilizar las funciones de agregacion (SUM,COUNT,MIN, MAX) 


Unir resultados
----------------------------------------------------------------------------------
 SELECT CONCAT(nombre," ",apellido) FROM autores
 UNION
  SELECT CONCAT(nombre," ",apellidos) FROM usuarios;


En la union debe tener las mismas columnas

solucion
 SELECT CONCAT(nombre," ",apellido) AS nombre_completo, ""  AS email FROM autores
 UNION
  SELECT CONCAT(nombre," ",apellidos) AS nombre_completo, email FROM usuarios;


 SELECT CONCAT(nombre," ",apellido) AS nombre_completo, "", pais_origen AS email FROM autores
 UNION
  SELECT CONCAT(nombre," ",apellidos) AS nombre_completo, email , "" FROM usuarios;
-----------------------------------------------------------------------------------------------

DELIMITER //
CREATE FUNCTION obtener_ventas() 
RETURNS INT
BEGIN
  SET @paginas = (SELECT (ROUND( RAND() * 100) * 6));
  RETURN @paginas;
END//

subconsultas
problematica :
Obtener el nombre completo de todos los autores cuyos valores hayan superado el promedio

Introduccion:
SET @promedio = (SELECT AVG(ventas) FROM libros);

SELECT 
autor_id 
FROM libros
 GROUP BY autor_id 
 HAVING SUM(ventas) >  @promedio;

ahora veamos como hacer esto con subconsultas;

SELECT <-- esta se ejecuta despues 
autor_id 
FROM libros
 GROUP BY autor_id 
 HAVING SUM(ventas) > (SELECT AVG(ventas) FROM libros);<--- esta se ejecuta primero

El orden en la que se ejecutan las subconsultas son del nivel mas bajo al mas alto

Finalmente la solucion a la problematica planteada para la pregunta para subconsulta es:

SELECT CONCAT(nombre, " ", apellido) AS nombre <-- esta se ejecuta al final(subconsulta principal)
FROM autores
WHERE autor_id IN(
SELECT <-- esta se ejecuta en segundo lugar
autor_id 
FROM libros
 GROUP BY autor_id 
 HAVING SUM(ventas) > (SELECT AVG(ventas) FROM libros)); <--- esta se ejecuta primero

la primera subconsulta devuelve el promedio
la segunda una lista de id 
y la principal el nombre completo en base a una lista 

Obtener el mensaje Disponible si el libro de titulo el hobbit se encuentra en nuestra tabla libros
en caso contrario ontener el mensaje No Disponible 

SELECT IF(
   EXISTS(SELECT libro_id FROM libros WHERE titulo = 'El hobbit'),
   'Disponible',
   'No Disponible'
 ) AS mensaje;

Ejercicios Base de datos de CodigoFacilito
-------------------------------------------------

LIBROS
-------------------------------------------------------

1 Obtener todos los libros escritos por autores que cuenten con un seudónimo.
SELECT titulo,autor_id  
FROM  libros
WHERE autor_id IN (
  SELECT autor_id
 FROM autores
 WHERE seudonimo IS NOT NULL 
)GROUP BY libro_id;

solucion alternativa con inner join 

SELECT (l.titulo) as titulo,(l.autor_id) as autor_id,CONCAT(a.nombre, " ", a.apellido) AS nombre_autor FROM 
 libros l inner join autores a on(l.autor_id = a.autor_id)
  WHERE a.seudonimo IS NOT NULL GROUP BY l.titulo; 


2 Obtener el título de todos los libros publicados en el año actual cuyos autores poseen un pseudónimo.
SELECT titulo,autor_id, fecha_publicacion,fecha_creacion  
FROM  libros
WHERE autor_id IN (
  SELECT autor_id
 FROM autores
 WHERE seudonimo IS NOT NULL 
) and DATE(fecha_publicacion) = CURDATE() GROUP BY titulo ;


3 Obtener todos los libros escritos por autores que cuenten con un seudónimo y que hayan nacido ante de 1965.
SELECT titulo,autor_id  
FROM  libros
WHERE autor_id IN (
  SELECT autor_id
 FROM autores
 WHERE seudonimo IS NOT NULL and fecha_nacimiento < '1965-12-31' 
) GROUP BY titulo;
  
  <> = diferente | <=> = igual
4 Colocar el mensaje no disponible a la columna descripción, en todos los libros publicados antes del año 2000.
UPDATE libros SET descripcion = 'no disponible' WHERE fecha_publicacion < '2000-01-01';

5 Obtener la llave primaria de todos los libros cuya descripción sea diferente de no disponible.
SELECT libro_id FROM libros WHERE descripcion <> 'no disponible'; 

6 Obtener el título de los últimos 3 libros escritos por el autor con id 2.

  SELECT titulo FROM libros WHERE autor_id = 2 
obtener el titulo de los primeros 5 libros escritos por el auttor de id 2
primero va la condicion y despues el limit
 SELECT titulo FROM libros WHERE autor_id = 2 LIMIT 5;

La solucion definitiva
SELECT libro_id, titulo,fecha_publicacion FROM libros WHERE autor_id = 2 GROUP BY libro_id 
 ORDER BY libro_id desc LIMIT 3;

7 Obtener en un mismo resultado la cantidad de libros escritos por autores con seudónimo y sin seudónimo.
SET @seudonimo = (SELECT COUNT(titulo) AS con_seudonimo
FROM  libros
WHERE autor_id IN (
  SELECT autor_id
 FROM autores
 WHERE seudonimo IS NOT NULL
));
SET @no_seudonimo = (SELECT COUNT(titulo) AS sin_seudonimo
FROM  libros
WHERE autor_id IN (
  SELECT autor_id
 FROM autores
 WHERE seudonimo IS NULL 
));

SELECT @seudonimo AS con_seudonimo,  @no_seudonimo AS sin_seudonimo;

8 Obtener la cantidad de libros publicados entre enero del año 2000 y enero del año 2005.

SELECT COUNT(libro_id) AS cantidad FROM libros WHERE fecha_publicacion  BETWEEN '2000-01-01' AND '2005-01-31';



9 Obtener el título y el número de ventas de los cinco libros más vendidos.

SELECT libro_id,titulo,ventas FROM libros GROUP BY libro_id ORDER BY ventas DESC LIMIT 5 ;


10 Obtener el título y el número de ventas de los cinco libros más vendidos de la última década.

SELECT libro_id,titulo,ventas,fecha_publicacion FROM libros
 WHERE fecha_publicacion BETWEEN '2010-01-01' AND '2020-06-30' 
GROUP BY libro_id ORDER BY ventas DESC LIMIT 5;


11 Obtener la cantidad de libros vendidos por los autores con id 1, 2 y 3.

SET @venta1 = (SELECT SUM(ventas) AS ventas_autor_id_1 FROM libros WHERE autor_id=1);

SET @venta2 =(SELECT SUM(ventas) AS ventas_autor_id_2 FROM libros WHERE autor_id=2);

SET @venta3 =(SELECT SUM(ventas) AS ventas_autor_id_3 FROM libros WHERE autor_id=3);

La solucion a la pregunta 11 es: 

SELECT autor_id AS autor, SUM(ventas) AS ventas
FROM libros
 WHERE autor_id = 1
 UNION  
SELECT  autor_id, SUM(ventas) 
FROM libros 
WHERE autor_id = 2 
UNION SELECT autor_id, SUM(ventas) 
FROM libros
WHERE autor_id = 3;

12 Obtener el título del libro con más páginas.
SELECT titulo FROM libros WHERE paginas IN(SELECT MAX(paginas) FROM libros);

13 Obtener todos los libros cuyo título comience con la palabra “La”.

SELECT titulo FROM libros WHERE titulo LIKE 'la%';

14 Obtener todos los libros cuyo título comience con la palabra “La” y termine con la letra “a”.

 SELECT titulo FROM libros WHERE titulo LIKE 'la%%a';

15 Establecer el stock en cero a todos los libros publicados antes del año de 1995

UPDATE libros SET stock = 0 WHERE fecha_publicacion < '1995-01-01';

16 Mostrar el mensaje Disponible si el libro con id 1 posee más de 5 ejemplares en stock, 
en caso contrario mostrar el mensaje No disponible.

SELECT IF(
  EXISTS( SELECT libro_id FROM libros WHERE libro_id = 1 AND stock > 5),
  'Disponible',
   'No Disponible'
)AS mensaje;

17 Obtener el título los libros ordenados por fecha de publicación del más reciente al más viejo.

SELECT libro_id,titulo,fecha_publicacion FROM libros GROUP BY libro_id ORDER BY fecha_publicacion DESC;

AUTORES
-------------------------------------------------------
1 Obtener el nombre de los autores cuya fecha de nacimiento sea posterior a 1950

SELECT autor_id, CONCAT(nombre, " ", apellido)AS nombre, fecha_nacimiento 
FROM autores 
WHERE 
fecha_nacimiento > '1950-12-31'
GROUP BY autor_id;

2 Obtene el nombre completo y la edad de todos los autores.

// se obtiene la fecha actual
SET @now = NOW();

 SELECT autor_id, CONCAT(nombre, " ", apellido)AS nombre, (YEAR(@now)-YEAR(fecha_nacimiento)) AS edad FROM autores;

3 Obtener el nombre completo de todos los autores cuyo último libro publicado sea posterior al 2005

SELECT autor_id,CONCAT(nombre, " ", apellido)AS nombre_completo
FROM autores WHERE autor_id IN(
 SELECT autor_id FROM libros WHERE fecha_publicacion > '2005-12-31' 
);


4 Obtener el id de todos los escritores cuyas ventas en sus libros superen el promedio
 SELECT autor_id FROM libros GROUP BY autor_id HAVING SUM(ventas) > (SELECT AVG(ventas) FROM libros);

5 Obtener el id de todos los escritores cuyas ventas en sus libros sean mayores a cien mil ejemplares.
 SELECT autor_id FROM libros GROUP BY autor_id HAVING SUM(ventas) > 100000;


funciones
----------------------------------

Crear una función la cual nos permita saber si un libro es candidato a préstamo o no.
 Retornar “Disponible” si el libro posee por lo menos un ejemplar en stock, 
en caso contrario retornar “No disponible.”

DELIMITER //

CREATE FUNCTION ver_stock8(id_libro INT UNSIGNED)
RETURNS VARCHAR(20)
BEGIN
   SET @stock = (
	SELECT IF(
	EXISTS(SELECT libro_id FROM libros WHERE libro_id = id_libro and stock >=1),
	 'Disponible',
         'No Disponible'
            )AS mensaje

    );

RETURN @stock;
  
END//

DELIMITER ;


JOIN  se obtiene registros de la union de dos tablas , los registros pueden encontrarse en la interseccion de ambas 
------------------------------------------------------
---------------------------------------------------------
Obtener el titulo de todos los libros y el nombre completo de su autor
SELECT
    li.titulo, 
    CONCAT(au.nombre, " ", au.apellido) AS nombre_autor,
    li.fecha_creacion
 FROM libros AS li
INNER JOIN autores AS au ON li.autor_id = au.autor_id;

Sub clausula using
---------------------
SELECT
    libros.titulo, 
    CONCAT(autores.nombre, " ", autores.apellido) AS nombre_autor,
    libros.fecha_creacion
 FROM libros 
INNER JOIN autores USING(autor_id);
En lo anterior se usa using porque autor_id es compartido en las dos tablas

pero ON permite condicionar la union de tablas ejemplo:
Obtener el titulo de todos los libros, el nombre completo de todos los autores siempre y cuando dicho autor  cuente con un seudonimo

SELECT
    libros.titulo, 
    CONCAT(autores.nombre, " ", autores.apellido) AS nombre_autor,
    libros.fecha_creacion
 FROM libros 
INNER JOIN autores ON libros.autor_id = autores.autor_id
           AND autores.seudonimo IS NOT NULL; se agregan mas condiciones

Lo anterior no se puede condiconar con using 


En resumen con ON se puede condicionar más columnas y con USING no


Left Join
................................................
LEFT JOIN 
LEFT OUTER JOIN  Son exactamente lo mismo 

LEFT JOIN se obtiene registros de la union de dos tablas , los registros pueden encontrarse en la interseccion de ambas o como
solo la tabla A (tabla del lado izquierdo)


en la libreria los usuarios pueden prestar libros , un usuario podra prestar más de un titulo
asi como un titulo podra ser prestado a mas de un usuario osea la relacion de ambas tablas sera

usuarios
libros

De muchos a muchos 

obtener el nombre completo de los usuarios y el id de los libros prestados 

usuarios = a
libros_usuarios = b

SELECT 
    CONCAT(nombre," ",apellidos),
    libros_usuarios.libro_id 
FROM usuarios
LEFT JOIN libros_usuarios ON usuarios.usuario_id = libros_usuarios.usuario_id;
lo null on los registros del lado izquierdo (usuarios)

Usuarios que han prestado libros

SELECT 
    CONCAT(nombre," ",apellidos),
    libros_usuarios.libro_id 
FROM usuarios
LEFT JOIN libros_usuarios ON usuarios.usuario_id = libros_usuarios.usuario_id
WHERE libros_usuarios.libro_id IS NOT NULL;

que no han prestado libros

SELECT 
    CONCAT(nombre," ",apellidos),
    libros_usuarios.libro_id 
FROM usuarios
LEFT JOIN libros_usuarios ON usuarios.usuario_id = libros_usuarios.usuario_id
WHERE libros_usuarios.libro_id IS NULL;



Right Join
------------
Right Join y Right OUTER Join son lo mismo
se obtiene registro de la union de dos tablas los registros pueden encontrase en la interseccion de ambas 
como en la tabla de la derecha

Se obtiene todos los usuarios que no han prestado un libro
SELECT 
    CONCAT(nombre," ",apellidos),
    libros_usuarios.libro_id 
FROM libros_usuarios
RIGHT JOIN usuarios ON usuarios.usuario_id = libros_usuarios.usuario_id
WHERE libros_usuarios.libro_id IS NULL;

A diferencia del anterior muestra tanto los registros del lado derecho como de la interseccion de las dos tablas
que coincide con usuario_id
SELECT 
    CONCAT(nombre," ",apellidos),
    libros_usuarios.libro_id 
FROM libros_usuarios
RIGHT JOIN usuarios ON usuarios.usuario_id = libros_usuarios.usuario_id;

multiples join
---------------------

obtener el nombre completo de los usuarios que hayan prestado un libro. El libro debio haber sido escrito
por un autor con seudonimo y ademas el prestamo debe de haberse realizado el dia de hoy
Se trabajaran con 4 tablas:

usuarios
libros_usuarios
libros
autores


-- multiples join
-- ---------------------
-- 1 seleccionar nombres de usuarios
-- 2 obtener todos los usuarios que hayan realizado un prestamo
-- 3 listarlibros prestados con autores con seudonimo
-- 4  prestamos que fueron realizados el dia de hoy

SELECT DISTINCT
    CONCAT(usuarios.nombre, " ",usuarios.apellidos) AS nombre_usuario
FROM usuarios
INNER JOIN libros_usuarios ON usuarios.usuario_id = libros_usuarios.usuario_id;

Quedando de la siguiente manera:

SELECT DISTINCT
    CONCAT(usuarios.nombre, " ",usuarios.apellidos) AS nombre_usuario
FROM usuarios
INNER JOIN libros_usuarios ON usuarios.usuario_id = libros_usuarios.usuario_id
            AND DATE(libros_usuarios.fecha_creacion) = CURDATE() 
INNER JOIN libros ON libros_usuarios.libro_id = libros.libro_id
INNER JOIN autores ON libros.autor_id = autores.autor_id 
            AND autores.seudonimo IS NOT NULL;

Productos Cartesianos
------------------------------

Es el resultado de unir multiples tablas sin especificar ninguna condicion de union 
se trabaja con CROSS JOIN   

SE GENERARA UN PRODUCTO CARTESIANO ENTRE USUARIOS Y LIBROS  
SELECT usuarios.username, libros.titulo FROM usuarios CROSS JOIN libros ORDER BY username DESC;   

Esto puede servir para ingresar estos resultados que arroja esta query 

Insertar el resultado de la query anterior dentro de una tabla mediante CROSS JOIN 

INSERT INTO libros_usuarios (libro_id,usuario_id) SELECT libro_id,usuario_id FROM usuarios CROSS JOIN libros;

vistas (relacionado a seguridad)
-------------------------------------------

la vista es un mecanismo que permite consultar datos a diferencias de las tablas en las vistas no se almacenan
los datos por lo que no hay que preocuparse de que las vistas tienen espacio en la memoria 


crear vistas

vista que nos permita conocer a todos los usuarios que han prestado libros en la ultima semana 
asi como la cantidad de libros prestados. No nos interesa los titulos prestados.

antes de crear la vista se debe generar la consulta
como nos interesa la cantidad no usaremos distinct sino group BY
una vez que agrupemos por el id es contar los registros 
y despues se genera una vista a partir de la consulta 

CREATE VIEW prestamos_usuarios_vw AS
SELECT
usuarios.usuario_id,
usuarios.nombre,
usuarios.email,
usuarios.username,
COUNT(usuarios.usuario_id) AS total_prestamos
FROM
usuarios
INNER JOIN libros_usuarios ON usuarios.usuario_id = libros_usuarios.usuario_id
GROUP BY usuarios.usuario_id;

para listar todas nuestras vistas con SHOW TABLES;
Y despues con select se consulta sus registros  como si fuera una tabla

SELECT * FROM prestamos_usuarios_vw;

obtener todos los usuarioscuyos prestamos hayan sido mayor  4 

SELECT * FROM prestamos_usuarios_vw WHERE total_prestamos > 4;

ELIMINAR UNA Vista :
DROP VIEW nombre_vista


